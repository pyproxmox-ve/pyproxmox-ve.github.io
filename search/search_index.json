{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyproxmox-ve","text":"<p>This is a Python module using aiohttp to interact with Proxmox VE's HTTP API.</p>"},{"location":"#how-to-install","title":"How to install","text":"<p>With Pydantic: <pre><code>pip install pyproxmox-ve[pydantic]\n</code></pre></p> <p>Without Pydantic: <pre><code>pip install pyproxmox-ve\n</code></pre></p> <p>Now let me tell you why you SHOULD install with Pydantic.</p>"},{"location":"#what-is-pydantic","title":"What is Pydantic?","text":"<p>Pydantic is a library which provides data validation and sanization. pyproxmox-ve has been tightly integrated with Pydantic data models to provide input validation before sending data to the API but also ensures the returned data is in-tact and formatted correctly according to Proxmox's API specification.</p> <p>Pydantic has various integrations out of the box but the most common one is VSCode, because Pydantic is built ontop of standard Python type annotations, we get an improved developer experience with autocompletion (<code>IntelliSense</code>) during the development lifecycle.</p> <p></p> <p></p> <p></p>"},{"location":"#do-you-provide-a-non-async-version","title":"Do you provide a non-async version?","text":"<p>No. This module only supports aiohttp which means you must develop using asynchronous programming. If you need a non-async module, then there are a few out there which you can use with a quick google.</p>"},{"location":"faq/","title":"Frequency Asked Questions","text":"<p>TO DO</p>"},{"location":"how_to_use_advanced/","title":"Advanced Usage","text":"<p>TO DO</p>"},{"location":"how_to_use_basic/","title":"Basic Usage","text":"<p>After installing the module, <code>pyproxmox-ve</code> is now ready to be used.</p> <ol> <li> <p>Import the <code>ProxmoxVEAPI</code> which is the basis of all API interaction.</p> <pre><code>from pyproxmox_ve import ProxmoxVEAPI\n</code></pre> </li> <li> <p>Initalise the API object with your API credentials</p> <pre><code>api = ProxmoxVEAPI(\n    url=\"https://192.0.2.100:8006\",\n    username=\"root\",\n    realm=\"pam\",\n    api_token_id=\"mytoken\",\n    api_token=\"abcd1234-efgh5678\",\n    use_pydantic=True # Set to False if you didn't `pip install pyproxmox-ve[pydantic]`\n)\n</code></pre> </li> </ol> <p>As a test, we can try to communicate with the API and list the version running:</p> <pre><code>version = await api.version.get_version()\n\nprint(version)\n&gt; version='8.1.3' repoid='b46aac3b42da5d15' release='8.1' console=None\n</code></pre> <p>Currently, all responses that return a status code of 400 or higher will raise an aiohttp ClientResponseError. For example, if my user authentication is wrong in the example above, I receive this error:</p> <pre><code># Bad Realm Example\n&gt; aiohttp.client_exceptions.ClientResponseError: 401, message=\"no such user ('root@badrealm')\", url=URL('https://192.0.2.100:8006/api2/json/version')\n\n# Bad Token Example\n&gt; aiohttp.client_exceptions.ClientResponseError: 401, message='invalid token value!', url=URL('https://192.0.2.100:8006/api2/json/version')\n</code></pre>"},{"location":"supported_endpoints/","title":"Access Resources","text":"Endpoint Method Method Name Purpose /access/users GET get_users Get all API Users /access/users POST create_user Create a new API User /access/users/{userid} GET get_user Get a specific API User /access/users/{userid} PUT update_user Update a specific API User /access/users/{userid} DELETE delete_user Delete a specific API User /access/users/{userid}/tfa GET get_user_tfa_types Get 2FA details for a specific API User /access/users/{userid}/unlock-tfa PUT unlock_user_tfa Unlock 2FA for a specific API User /access/users/{userid}/token GET get_user_tokens Get a specific API User's Tokens /access/users/{userid}/token/{tokenid} GET get_user_token Get a specific API User's Token /access/users/{userid}/token/{tokenid} POST create_user_token Create a new API token for an existing API User /access/users/{userid}/token/{tokenid} PUT update_user_token Update a specific API User's Token /access/users/{userid}/token/{tokenid} DELETE delete_user_token Delete a specific API User's Token"},{"location":"code/general_design/","title":"API General Design","text":"<p>This page documents the general API design for pyproxmox-ve. Here you should grasp a quick understanding on how to access any Class method implemented in the module to create, read, update or delete a resource on the Proxmox VE API.</p>"},{"location":"code/general_design/#proxmoxveapi","title":"ProxmoxVEAPI","text":"<p>The ProxmoxVEAPI class is where you will spend most of your time. Each group of API resources are typically implemented in their own separate file/class unless there are only a few API operations then they may be housed into a common file.</p> <p>Let's take the <code>/access/users/*</code> path as an example. Here are all the API endpoints as of Proxmox v8.1 under this API path:</p> Endpoint Method Purpose /access/users GET Get all API Users /access/users POST Create a new API User /access/users/{userid} GET Get a specific API User /access/users/{userid} PUT Update a specific API User /access/users/{userid} DELETE Delete a specific API User /access/users/{userid}/tfa GET Get 2FA details for a specific API User /access/users/{userid}/unlock-tfa PUT Unlock 2FA for a specific API User /access/users/{userid}/token GET Get a specific API User's Tokens /access/users/{userid}/token/{tokenid} GET Get a specific API User's Token /access/users/{userid}/token/{tokenid} POST Create a new API token for an existing API User /access/users/{userid}/token/{tokenid} PUT Update a specific API User's Token /access/users/{userid}/token/{tokenid} DELETE Delete a specific API User's Token <p>Majority of each endpoint pattern is modelled as an API until it becomes to cumbersome. Therefore we model firstly the <code>/access</code> pattern as an API object called <code>AccessAPI</code> and then <code>/access/users</code> pattern as <code>AccessUsersAPI</code>.</p> <pre><code>class AccessAPI:\n    def __init__(self, api: \"ProxmoxVEAPI\") -&gt; None:\n        self.api = api\n        self.users = AccessUsersAPI(api)\n</code></pre> <p>We could go further and implement a <code>AccessUsersTokenAPI</code> object under our <code>AccessUsersAPI</code> but since there are a handful of endpoints, it is modelled somewhat like this:</p> <pre><code>class AccessUsersAPI(BaseResourceAPI):\n    async def get_users(\n        self, enabled: bool = None, full: bool = False\n    ) -&gt; list[User]:\n        \"\"\"Gathers all Users.\n\n        Args:\n            enabled:        Optional filter for enable property.\n            full:           Include group and token information.\n        \"\"\"\n        ...\n    async def get_user_token(\n        self, user_id: str, token_id: str\n    ) -&gt; UserToken | dict:\n        \"\"\"Get a specific users API token.\n\n        Args:\n            user_id:        User ID in the format of &lt;username&gt;@&lt;realm&gt;\n            token_id:       Token ID\n        \"\"\"\n        ...\n</code></pre> <p>Ok, but where is the <code>AccessAPI</code>?</p>"},{"location":"code/general_design/#apis-attached-to-the-proxmoxveapi-class","title":"APIs attached to the ProxmoxVEAPI Class","text":"<p>The ProxmoxVEAPI would implement a simple variable like this:</p> <pre><code>class ProxmoxVEAPI:\n    ...\n    def __init__(\n        self,\n        ...\n    ) -&gt; None:\n        ...\n\n        # APIs\n        self.access = AccessAPI(self)\n        self.version = VersionAPI(self)\n</code></pre> <p>So if we want to get the users or a specific user token in the implementation shown previously, we do this:</p> <pre><code>api = ProxmoxVEAPI(...)\n\nusers = await api.access.users.get_users()\nuser_token = await api.acess.users.get_user_token(...)\n</code></pre>"},{"location":"code/general_design/#aiohttp-specific-implementation","title":"aiohttp specific implementation","text":"<p>Typically you won't need to change this behaviour but ProxmoxVEAPI allows you to pass in a seperate:</p> <ul> <li>SSLContext</li> <li>BaseConnector (you should only ever use TCPConnector)</li> <li>ClientSession</li> </ul> <p>If you do not know what these do, don't touch them and leave them be!</p>"},{"location":"code/general_design/#api-version-and-api-types","title":"API Version and API Types","text":"<p>There are no plans to implement any older API versions or different API types, the current supported are version <code>api2</code> and type <code>json</code>.</p>"},{"location":"code/general_design/#to-pydantic-or-not-to-pydantic","title":"To Pydantic or not to Pydantic","text":"<p>Pydantic is an optional installation in this module, however it is a requirement for anyone looking to contribute due to the tests and compatibility. To avoid forcing this module to be a requirement, there has been some slight hacks put in place to make type hints work properly in editors, and to ensure those who do not install pydantic don't run into import errors.</p> <p>There are 3 key parts I would like to stress to the reader and they are as follows:</p> <ol> <li> <p><code>use_pydantic</code> is important when initializing ProxmoxVEAPI, because this will determine if the logic is used to load data into Pydantic models, so if you don't set this to <code>True</code> then you may run into AttributeErrors and other errors.</p> </li> <li> <p><code>TYPE_CHECKING</code> is a must to avoid import errors for users not using Pydantic, however return type hints will break if you do not import <code>from __future__ import annotations</code> at the top of the file in this module.</p> </li> <li> <p>Finally and the big one, since we can not import Pydantic models directly in the API implementation files, we can't pass it into the <code>query()</code>, <code>create()</code> or <code>update()</code> functions. So to dynamically load these models we need a way to tell which model (and where it is located) so that we can attempt to dynamically import the model and validate the data. This is currently done using a <code>tuple(str, str)</code> like this: <code>(\"pyproxmox_ve.models.user\", \"UserCreate\")</code>, this method is currently being reviewed and could change at a later date.</p> </li> </ol> <p>Note</p> <p>If you would like to understand more about point 3, then this logic is stored inside the ProxmoxVEAPI class, specifically under the function _normalize_data method.</p>"},{"location":"code/pyproxmoxveapi/","title":"ProxmoxVEAPI","text":"<p>aiohttp wrapper which handles a lot of the heavy lifting to interact with the Proxmox VE API (only http(s) protocol is supported).</p> <p>Majority if not all endpoint groups will be modelled under their respective name, for example the <code>/access/users</code> endpoint is modelled as:     api.access.users.get_users()</p> <p>When there is a large nested endpoint like     <code>/nodes/{node_id}/qemu/{qemu_id}/firewall/rules/{id}</code>, nested required     path variables are required in the called function, this is modelled as:     api.nodes.qemu.firewall.get_qemu_firewall(node_id=1, qemu_id=2, id=3)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>ProxmoxVE API Url (eg. https://localhost:8086)</p> required <code>username</code> <code>str</code> <p>Username to authenticate with</p> required <code>realm</code> <code>str</code> <p>Realm to authenticate with</p> required <code>api_token_id</code> <code>str</code> <p>API Token ID to authenticate with</p> required <code>api_token</code> <code>str</code> <p>API Token to authenticate with</p> required <code>api_version</code> <code>str</code> <p>API Version (only <code>api2</code> is currently supported)</p> <code>'api2'</code> <code>api_type</code> <code>str</code> <p>API Type (only <code>json</code> is currently supported)</p> <code>'json'</code> <code>ssl_context</code> <code>SSLContext | None</code> <p>SSL Context object to pass to the aiohttp session</p> <code>None</code> <code>connector</code> <code>BaseConnector | None</code> <p>Connector object to pass to the aiohttp session (only <code>TCPConnector</code> is currently supported)</p> <code>None</code> <code>session</code> <code>ClientSession | None</code> <p>ClientSession object to pass if you want to override anything</p> <code>None</code> <code>use_pydantic</code> <code>bool</code> <p>Use the Pydantic library for data validation and accessing data via Python objects</p> <code>False</code> <code>kwargs</code> <p>kwargs are passed to the ClientSession that is automatically created if <code>session</code> is not used</p> <code>{}</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>class ProxmoxVEAPI:\n    \"\"\"aiohttp wrapper which handles a lot of the heavy lifting to interact with\n    the Proxmox VE API (only http(s) protocol is supported).\n\n    Majority if not all endpoint groups will be modelled under their respective\n    name, for example the `/access/users` endpoint is modelled as:\n        api.access.users.get_users()\n\n    When there is a large nested endpoint like\n        `/nodes/{node_id}/qemu/{qemu_id}/firewall/rules/{id}`, nested required\n        path variables are required in the called function, this is modelled as:\n        api.nodes.qemu.firewall.get_qemu_firewall(node_id=1, qemu_id=2, id=3)\n\n    Args:\n        url:            ProxmoxVE API Url (eg. https://localhost:8086)\n        username:       Username to authenticate with\n        realm:          Realm to authenticate with\n        api_token_id:   API Token ID to authenticate with\n        api_token:      API Token to authenticate with\n        api_version:    API Version (only `api2` is currently supported)\n        api_type:       API Type (only `json` is currently supported)\n        ssl_context:    SSL Context object to pass to the aiohttp session\n        connector:      Connector object to pass to the aiohttp session\n            (only `TCPConnector` is currently supported)\n        session:        ClientSession object to pass if you want to\n            override anything\n        use_pydantic:   Use the Pydantic library for data validation and\n            accessing data via Python objects\n        kwargs:         kwargs are passed to the ClientSession that is\n            automatically created if `session` is not used\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        username: str,\n        realm: str,\n        api_token_id: str,\n        api_token: str,\n        api_version: str = \"api2\",\n        api_type: str = \"json\",\n        ssl_context: SSLContext | None = None,\n        verify_ssl: bool = False,\n        connector: BaseConnector | None = None,\n        session: ClientSession | None = None,\n        use_pydantic: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        if api_version not in SUPPORTED_API_VERSIONS:\n            raise NotImplementedError(\n                f\"API version {api_version} is not supported in this release.\"\n            )\n\n        if api_type not in SUPPORTED_API_TYPES:\n            raise NotImplementedError(\n                f\"API type {api_type} is not supported in this release.\"\n            )\n\n        self.username = username\n        self.realm = realm\n        self.api_token_id = api_token_id\n        self.api_token = api_token\n        self.api_version = api_version\n        self.api_type = api_type\n\n        try:\n            self.url = URL(url).joinpath(self.api_version, self.api_type)\n        except (ValueError, TypeError) as err:\n            raise err\n\n        self.ssl_context = ssl_context\n        self.verify_ssl = verify_ssl\n        self.connector = connector\n        if not self.connector:\n            self.connector = TCPConnector(\n                ssl_context=self.ssl_context, ssl=self.verify_ssl\n            )\n\n        self.session = session\n        if not self.session:\n            self.session = ClientSession(\n                base_url=self.url,\n                auth=PVEAPITokenAuth(\n                    login=f\"{self.username}@{self.realm}!{self.api_token_id}\",\n                    password=self.api_token,\n                ),\n                connector=self.connector,\n                **kwargs,\n            )\n\n        self.use_pydantic = use_pydantic\n        if self.use_pydantic:\n            module_found = importlib.util.find_spec(\"pydantic\")\n            if not module_found:\n                raise exceptions.ProxmoxAPIPydanticNotInstalledError\n\n        # APIs\n        self.access = AccessAPI(self)\n        self.version = VersionAPI(self)\n\n    async def __aenter__(self) -&gt; \"ProxmoxVEAPI\":\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        await self.close()\n\n    async def close(self) -&gt; None:\n        if self.session:\n            await self.session.close()\n\n    async def http_request(\n        self,\n        endpoint: str,\n        method: str,\n        data: dict = None,\n        data_key: str = \"\",\n        **kwargs,\n    ) -&gt; dict | None:\n        \"\"\"aiohttp request shorthand function to handle simple logic.\n\n        Args:\n            endpoint:   API Endpoint\n            method:     HTTP Method (GET, POST, PUT, DELETE)\n            data_key:   nested key to export info if present\n        \"\"\"\n        ctx = None\n        match method.upper():\n            case \"GET\":\n                ctx = self.session.get\n            case \"POST\":\n                ctx = self.session.post\n            case \"PUT\":\n                ctx = self.session.put\n            case \"DELETE\":\n                ctx = self.session.delete\n            case _:\n                raise KeyError(f\"Method `{method}` is not valid\")\n\n        r = await ctx(\n            url=f\"/{self.api_version}/{self.api_type}\" + endpoint,\n            data=data,\n            **kwargs,\n        )\n        if not r.ok:\n            r.raise_for_status()\n\n        data = await r.json()\n        if data_key:\n            data = data.get(data_key)\n\n        return data\n\n    async def delete(self, endpoint: str, **kwargs) -&gt; dict | None:\n        \"\"\"Delete a resource on the Proxmox VE API.\n\n        Args:\n            endpoint:   API Endpoint\n        \"\"\"\n        return await self.http_request(\n            endpoint=endpoint, method=\"DELETE\", **kwargs\n        )\n\n    # update() and create() functions seem like its just duplicated code, but in\n    # the event we need to change any logic for one of the operations,\n    # I've separated the code to allow flexibility in the future otherwise it\n    # could be considered a very major breaking change\n    async def update(\n        self,\n        endpoint: str,\n        obj_in: dict | ProxmoxBaseModel = None,\n        module_model: tuple[str, str] = None,\n        data_key: str = \"\",\n        validate_response: bool = False,\n        response_model: tuple[str, str] = None,\n        **kwargs,\n    ) -&gt; ProxmoxBaseModel | dict | None:\n        \"\"\"Update a resource on the Proxmox VE API. As of PVE v8.1, most if\n        not all PUT endpoints return null, however when data is returned you can\n        pass a Pydantic model to validate the response body if validate_response\n        is set to True. It also appears that the PUT response isn't the new\n        updated object but the old object before the update.\n\n        Args:\n            endpoint:           API Endpoint\n            obj_in:             Resource\n            data_key:           Proxmox API typically returns everything in\n                'data' key, this is used to extract the relevant data directly\n                from the ClientResponse\n            module_model:       Path to module and model to dynamically load if\n                using Pydantic validation library\n            validate_response:  Validate the response using Pydantic\n            response_model:     Path to module and model to dynamically validate\n                the respose using Pydantic library if this model is the same as\n                the original model to update the object, leave this blank and we\n                will automatically use the `module_model` to validate the\n                response.\n        \"\"\"\n        data = None\n\n        # Exclude unset to prevent default values updating unset values\n        if obj_in:\n            data = self._normalize_data(\n                obj_in=obj_in,\n                module_model=module_model,\n                exclude_unset=True,\n            )\n\n        # data will automatically set application/x-www-form-urlencoded which\n        # Proxmox API is expecting\n        r_data = await self.http_request(\n            endpoint=endpoint,\n            method=\"PUT\",\n            data=data,\n            data_key=data_key,\n            **kwargs,\n        )\n\n        # If Pydantic is used, we can validate the response returned back to the\n        # user, we can either pass in a separate model using `response_model`,\n        # otherwise if this is empty we assume the same model passed to update\n        # the data can be used to validate the response.\n        # Be careful using the same data model to validate the response as it\n        # could be a unique field required when creating the resource, but is\n        # never returned in the object back from the API\n        if self.use_pydantic:\n            if validate_response:\n                if not response_model:\n                    response_model = module_model  # Use same Model that was used to update, to validate response\n                validation_model = self._get_pydantic_model(*response_model)\n                r_data = self._model_validate(\n                    obj_in=r_data, model=validation_model\n                )\n\n        return r_data\n\n    async def create(\n        self,\n        endpoint: str,\n        obj_in: dict | ProxmoxBaseModel,\n        module_model: tuple[str, str] = None,\n        data_key: str = \"\",\n        validate_response: bool = False,\n        response_model: tuple[str, str] = None,\n        **kwargs,\n    ) -&gt; ProxmoxBaseModel | dict | None:\n        \"\"\"Create a resource on the Proxmox VE API. As of PVE v8.1, most if not all POST endpoints\n        return null, however when data is returned you can pass a Pydantic model to validate the response\n        body if validate_response is set to True.\n\n        Args:\n            endpoint:           API Endpoint\n            obj_in:             Resource\n            data_key:           Proxmox API typically returns everything in 'data' key, this is\n                used to extract the relevant data directly from the ClientResponse\n            module_model:       Path to module and model to dynamically load if using Pydantic validation library\n            validate_response:  Validate the response using Pydantic\n            response_model:     Path to module and model to dynamically validate the respose using Pydantic library\n                if this model is the same as the original model to create the object, leave this blank and we will\n                automatically use the `module_model` to validate the response.\n        \"\"\"\n        data = self._normalize_data(obj_in=obj_in, module_model=module_model)\n        r_data = await self.http_request(\n            endpoint=endpoint,\n            method=\"POST\",\n            data=data,\n            data_key=data_key,\n            **kwargs,\n        )  # data will automatically set application/x-www-form-urlencoded which Proxmox API is expecting\n\n        # If Pydantic is used, we can validate the response returned back to the user,\n        # we can either pass in a separate model using `response_model`, otherwise if this is empty we assume\n        # the same model passed to update the data can be used to validate the response.\n        # Be careful using the same data model to validate the response as it could be a unique field required\n        # when creating the resource, but is never returned in the object back from the API\n        if self.use_pydantic:\n            if validate_response:\n                if not response_model:\n                    response_model = module_model  # Use same Model that was used to create, to validate response\n                validation_model = self._get_pydantic_model(*response_model)\n                r_data = self._model_validate(\n                    obj_in=r_data, model=validation_model\n                )\n\n        return r_data\n\n    async def query(\n        self,\n        endpoint: str,\n        data_key: str = \"data\",\n        module_model: tuple[str, str] = None,\n        **kwargs,\n    ) -&gt; ProxmoxBaseModel | dict | None:\n        \"\"\"Basic function to return the JSON directly from any HTTP operation. As of PVE v8.1, most if not all GET\n        endpoints will return the data nested inside the response in a key called `data`.\n\n        Args:\n            method:         GET, POST, PUT or DELETE\n            endpoint:       API Endpoint\n            data_key:       This is used to extract the relevant data directly from the ClientResponse body\n            module_model:   Path to module and model to dynamically load if using Pydantic library\n        \"\"\"\n        data = await self.http_request(\n            endpoint=endpoint, data_key=data_key, **kwargs\n        )\n\n        # Most PVE endpoints return null if it doesn't exist, so this logic should be handled by each function\n        # if its expecting some returned data.\n        if not data:\n            return None\n\n        if self.use_pydantic:\n            pydantic_model = self._get_pydantic_model(*module_model)\n            data = self._model_validate(obj_in=data, model=pydantic_model)\n\n        return data\n\n    async def _extract_response_json(\n        self, response: ClientResponse, root_keys: list[str] = []\n    ) -&gt; dict:\n        \"\"\"Attempts to extract JSON from a response and check for various root keys exist in the body.\n\n        Args:\n            response:   ClientResponse object\n            root_keys:  List of keys to check in the initial JSON body\n        \"\"\"\n        try:\n            data = await response.json()\n        except Exception as err:\n            raise err\n\n        if not all(k in data for k in root_keys):\n            raise KeyError(\n                f\"JSON Body is missing one of the following required keys: {root_keys}\"\n            )\n\n        return data\n\n    def _build_params(self, **kwargs):\n        \"\"\"Builds parameters according to how Proxmox VE API wants it. Boolean logic in the API\n        will require an integer and doesn't attempt to convert based on `yes`, `true, `y`, etc...\n\n        Args:\n            kwargs:     dict of arguments\n        \"\"\"\n        params = {}\n        for k, v in kwargs.items():\n            if v is None:\n                continue\n\n            # Handle Logic for PVE API\n            if isinstance(v, bool):\n                params[k] = int(v)\n            elif isinstance(v, str):\n                # this is here for future implementation :) this obviously needs work since str(v) is just pointless\n                params[k] = str(v)\n\n        return params\n\n    def _get_pydantic_model(\n        self, module_name: str, model_name: str\n    ) -&gt; ProxmoxBaseModel:\n        \"\"\"Attempts to find a Pydantic Model and return it.\n\n        Args:\n            module_name:        Name of the module\n            model_name:         Name of the Pydantic model\n        \"\"\"\n        try:\n            pydantic_model: \"ProxmoxBaseModel\" = getattr(\n                importlib.import_module(module_name), model_name\n            )\n        except AttributeError as err:\n            raise err\n        except Exception as err:\n            raise err\n\n        return pydantic_model\n\n    def _model_validate(\n        self, obj_in: dict | list[dict], model: ProxmoxBaseModel, **kwargs\n    ) -&gt; ProxmoxBaseModel | list[ProxmoxBaseModel]:\n        \"\"\"Shorthand function to validate Pydantic model(s).\n\n        Args:\n            obj_in:     Data\n            model:      Pydantic Model\n        \"\"\"\n        if isinstance(obj_in, dict):\n            data = model.model_validate(obj_in, **kwargs)\n        elif isinstance(obj_in, list):\n            data = [model.model_validate(d, **kwargs) for d in obj_in]\n        else:\n            raise exceptions.ProxmoxAPIPydanticModelError\n\n        return data\n\n    def _model_dump(\n        self,\n        obj_in: ProxmoxBaseModel | list[ProxmoxBaseModel],\n        model: ProxmoxBaseModel,\n        exclude_none: bool = True,\n        exclude_unset: bool = False,\n        by_alias: bool = True,\n        **kwargs,\n    ) -&gt; dict | list[dict]:\n        \"\"\"Shorthand function to dump Pydantic model(s) with relevant logic to make sure\n        Proxmox PVE API is happy (eg. alias is already required to ensure underscore are replaced with hyphens).\n\n        Args:\n            obj_in:     Data\n            model:      Pydantic Model\n        \"\"\"\n        if isinstance(obj_in, model):\n            return obj_in.model_dump(\n                exclude_none=exclude_none,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                **kwargs,\n            )\n        elif isinstance(obj_in, list):\n            return [\n                m.model_dump(\n                    exclude_none=exclude_none,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    **kwargs,\n                )\n                for m in obj_in\n            ]\n        else:\n            raise exceptions.ProxmoxAPIPydanticModelError\n\n    def _normalize_data(\n        self,\n        obj_in: ProxmoxBaseModel | dict,\n        module_model: tuple[str, str] = None,\n        exclude_none: bool = True,\n        exclude_unset: bool = False,\n        by_alias: bool = True,\n    ) -&gt; ProxmoxBaseModel | dict:\n        \"\"\"Shorthand function to return data from either a dict or Pydantic Object, if pydantic isn't used\n        then we simply use json.dumps, otherwise if it is used we need to pass in module_model which is a tuple\n        that attempts to dynamically load the Pydantic model (module_path, model_name) eg. (\"pyproxmox_ve.models.user\", \"UserCreate\"),\n        this assumes there is a Pydantic model called `UserCreate` inside the file `pyproxmox_ve.models.user.py`.\n\n        exclude_none, exclude_unset and by_alias are all functionality of Pydantic model_validation and model_dump. We pass this between functions\n        to avoid accidently setting default values on specific operations (eg. updating a user) because if the field is not provided during a PUT,\n        we don't want to explictly update the field back to the default as we might for example, renable a disabled user. So we tend to set `exclude_unset`\n        to True when we are performing PUT operations instead of writing all the logic for this command just for PUT operations.\n\n        Args:\n            obj_in:         Dict or Pydantic Object\n            module_model:   Tuple of module_name and model_name to dynamically load Pydantic object\n            exclude_none:   Passed to Pydantic functions\n            exclude_unset:  Passed to Pydantic functions\n            by_alias:       Passed to Pydantic functions\n        \"\"\"\n        if self.use_pydantic:\n            if not module_model:\n                raise exceptions.ProxmoxAPIPydanticModelError\n\n            pydantic_model = self._get_pydantic_model(*module_model)\n\n            # Check if the model has already been validated otherwise manually validate the data against the Pydantic model\n            # Technically you can load data while bypassing validation, so this part here is risky... It's expected that the user\n            # has already performed the `.model_validate()` function on the Pydantic Model.\n            if isinstance(obj_in, pydantic_model):\n                obj = obj_in\n            elif isinstance(obj_in, (list, dict)):\n                obj = self._model_validate(obj_in=obj_in, model=pydantic_model)\n            else:\n                raise TypeError\n\n            data = self._model_dump(\n                obj_in=obj,\n                model=pydantic_model,\n                exclude_none=exclude_none,\n                exclude_unset=exclude_unset,\n                by_alias=by_alias,\n            )\n        else:\n            data = json.dumps(obj_in)\n\n        return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._build_params","title":"<code>_build_params(**kwargs)</code>","text":"<p>Builds parameters according to how Proxmox VE API wants it. Boolean logic in the API will require an integer and doesn't attempt to convert based on <code>yes</code>, <code>true,</code>y`, etc...</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>dict of arguments</p> <code>{}</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>def _build_params(self, **kwargs):\n    \"\"\"Builds parameters according to how Proxmox VE API wants it. Boolean logic in the API\n    will require an integer and doesn't attempt to convert based on `yes`, `true, `y`, etc...\n\n    Args:\n        kwargs:     dict of arguments\n    \"\"\"\n    params = {}\n    for k, v in kwargs.items():\n        if v is None:\n            continue\n\n        # Handle Logic for PVE API\n        if isinstance(v, bool):\n            params[k] = int(v)\n        elif isinstance(v, str):\n            # this is here for future implementation :) this obviously needs work since str(v) is just pointless\n            params[k] = str(v)\n\n    return params\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._extract_response_json","title":"<code>_extract_response_json(response, root_keys=[])</code>  <code>async</code>","text":"<p>Attempts to extract JSON from a response and check for various root keys exist in the body.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ClientResponse</code> <p>ClientResponse object</p> required <code>root_keys</code> <code>list[str]</code> <p>List of keys to check in the initial JSON body</p> <code>[]</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def _extract_response_json(\n    self, response: ClientResponse, root_keys: list[str] = []\n) -&gt; dict:\n    \"\"\"Attempts to extract JSON from a response and check for various root keys exist in the body.\n\n    Args:\n        response:   ClientResponse object\n        root_keys:  List of keys to check in the initial JSON body\n    \"\"\"\n    try:\n        data = await response.json()\n    except Exception as err:\n        raise err\n\n    if not all(k in data for k in root_keys):\n        raise KeyError(\n            f\"JSON Body is missing one of the following required keys: {root_keys}\"\n        )\n\n    return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._get_pydantic_model","title":"<code>_get_pydantic_model(module_name, model_name)</code>","text":"<p>Attempts to find a Pydantic Model and return it.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the module</p> required <code>model_name</code> <code>str</code> <p>Name of the Pydantic model</p> required Source code in <code>pyproxmox_ve/api.py</code> <pre><code>def _get_pydantic_model(\n    self, module_name: str, model_name: str\n) -&gt; ProxmoxBaseModel:\n    \"\"\"Attempts to find a Pydantic Model and return it.\n\n    Args:\n        module_name:        Name of the module\n        model_name:         Name of the Pydantic model\n    \"\"\"\n    try:\n        pydantic_model: \"ProxmoxBaseModel\" = getattr(\n            importlib.import_module(module_name), model_name\n        )\n    except AttributeError as err:\n        raise err\n    except Exception as err:\n        raise err\n\n    return pydantic_model\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._model_dump","title":"<code>_model_dump(obj_in, model, exclude_none=True, exclude_unset=False, by_alias=True, **kwargs)</code>","text":"<p>Shorthand function to dump Pydantic model(s) with relevant logic to make sure Proxmox PVE API is happy (eg. alias is already required to ensure underscore are replaced with hyphens).</p> <p>Parameters:</p> Name Type Description Default <code>obj_in</code> <code>ProxmoxBaseModel | list[ProxmoxBaseModel]</code> <p>Data</p> required <code>model</code> <code>ProxmoxBaseModel</code> <p>Pydantic Model</p> required Source code in <code>pyproxmox_ve/api.py</code> <pre><code>def _model_dump(\n    self,\n    obj_in: ProxmoxBaseModel | list[ProxmoxBaseModel],\n    model: ProxmoxBaseModel,\n    exclude_none: bool = True,\n    exclude_unset: bool = False,\n    by_alias: bool = True,\n    **kwargs,\n) -&gt; dict | list[dict]:\n    \"\"\"Shorthand function to dump Pydantic model(s) with relevant logic to make sure\n    Proxmox PVE API is happy (eg. alias is already required to ensure underscore are replaced with hyphens).\n\n    Args:\n        obj_in:     Data\n        model:      Pydantic Model\n    \"\"\"\n    if isinstance(obj_in, model):\n        return obj_in.model_dump(\n            exclude_none=exclude_none,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            **kwargs,\n        )\n    elif isinstance(obj_in, list):\n        return [\n            m.model_dump(\n                exclude_none=exclude_none,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                **kwargs,\n            )\n            for m in obj_in\n        ]\n    else:\n        raise exceptions.ProxmoxAPIPydanticModelError\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._model_validate","title":"<code>_model_validate(obj_in, model, **kwargs)</code>","text":"<p>Shorthand function to validate Pydantic model(s).</p> <p>Parameters:</p> Name Type Description Default <code>obj_in</code> <code>dict | list[dict]</code> <p>Data</p> required <code>model</code> <code>ProxmoxBaseModel</code> <p>Pydantic Model</p> required Source code in <code>pyproxmox_ve/api.py</code> <pre><code>def _model_validate(\n    self, obj_in: dict | list[dict], model: ProxmoxBaseModel, **kwargs\n) -&gt; ProxmoxBaseModel | list[ProxmoxBaseModel]:\n    \"\"\"Shorthand function to validate Pydantic model(s).\n\n    Args:\n        obj_in:     Data\n        model:      Pydantic Model\n    \"\"\"\n    if isinstance(obj_in, dict):\n        data = model.model_validate(obj_in, **kwargs)\n    elif isinstance(obj_in, list):\n        data = [model.model_validate(d, **kwargs) for d in obj_in]\n    else:\n        raise exceptions.ProxmoxAPIPydanticModelError\n\n    return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI._normalize_data","title":"<code>_normalize_data(obj_in, module_model=None, exclude_none=True, exclude_unset=False, by_alias=True)</code>","text":"<p>Shorthand function to return data from either a dict or Pydantic Object, if pydantic isn't used then we simply use json.dumps, otherwise if it is used we need to pass in module_model which is a tuple that attempts to dynamically load the Pydantic model (module_path, model_name) eg. (\"pyproxmox_ve.models.user\", \"UserCreate\"), this assumes there is a Pydantic model called <code>UserCreate</code> inside the file <code>pyproxmox_ve.models.user.py</code>.</p> <p>exclude_none, exclude_unset and by_alias are all functionality of Pydantic model_validation and model_dump. We pass this between functions to avoid accidently setting default values on specific operations (eg. updating a user) because if the field is not provided during a PUT, we don't want to explictly update the field back to the default as we might for example, renable a disabled user. So we tend to set <code>exclude_unset</code> to True when we are performing PUT operations instead of writing all the logic for this command just for PUT operations.</p> <p>Parameters:</p> Name Type Description Default <code>obj_in</code> <code>ProxmoxBaseModel | dict</code> <p>Dict or Pydantic Object</p> required <code>module_model</code> <code>tuple[str, str]</code> <p>Tuple of module_name and model_name to dynamically load Pydantic object</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Passed to Pydantic functions</p> <code>True</code> <code>exclude_unset</code> <code>bool</code> <p>Passed to Pydantic functions</p> <code>False</code> <code>by_alias</code> <code>bool</code> <p>Passed to Pydantic functions</p> <code>True</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>def _normalize_data(\n    self,\n    obj_in: ProxmoxBaseModel | dict,\n    module_model: tuple[str, str] = None,\n    exclude_none: bool = True,\n    exclude_unset: bool = False,\n    by_alias: bool = True,\n) -&gt; ProxmoxBaseModel | dict:\n    \"\"\"Shorthand function to return data from either a dict or Pydantic Object, if pydantic isn't used\n    then we simply use json.dumps, otherwise if it is used we need to pass in module_model which is a tuple\n    that attempts to dynamically load the Pydantic model (module_path, model_name) eg. (\"pyproxmox_ve.models.user\", \"UserCreate\"),\n    this assumes there is a Pydantic model called `UserCreate` inside the file `pyproxmox_ve.models.user.py`.\n\n    exclude_none, exclude_unset and by_alias are all functionality of Pydantic model_validation and model_dump. We pass this between functions\n    to avoid accidently setting default values on specific operations (eg. updating a user) because if the field is not provided during a PUT,\n    we don't want to explictly update the field back to the default as we might for example, renable a disabled user. So we tend to set `exclude_unset`\n    to True when we are performing PUT operations instead of writing all the logic for this command just for PUT operations.\n\n    Args:\n        obj_in:         Dict or Pydantic Object\n        module_model:   Tuple of module_name and model_name to dynamically load Pydantic object\n        exclude_none:   Passed to Pydantic functions\n        exclude_unset:  Passed to Pydantic functions\n        by_alias:       Passed to Pydantic functions\n    \"\"\"\n    if self.use_pydantic:\n        if not module_model:\n            raise exceptions.ProxmoxAPIPydanticModelError\n\n        pydantic_model = self._get_pydantic_model(*module_model)\n\n        # Check if the model has already been validated otherwise manually validate the data against the Pydantic model\n        # Technically you can load data while bypassing validation, so this part here is risky... It's expected that the user\n        # has already performed the `.model_validate()` function on the Pydantic Model.\n        if isinstance(obj_in, pydantic_model):\n            obj = obj_in\n        elif isinstance(obj_in, (list, dict)):\n            obj = self._model_validate(obj_in=obj_in, model=pydantic_model)\n        else:\n            raise TypeError\n\n        data = self._model_dump(\n            obj_in=obj,\n            model=pydantic_model,\n            exclude_none=exclude_none,\n            exclude_unset=exclude_unset,\n            by_alias=by_alias,\n        )\n    else:\n        data = json.dumps(obj_in)\n\n    return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI.create","title":"<code>create(endpoint, obj_in, module_model=None, data_key='', validate_response=False, response_model=None, **kwargs)</code>  <code>async</code>","text":"<p>Create a resource on the Proxmox VE API. As of PVE v8.1, most if not all POST endpoints return null, however when data is returned you can pass a Pydantic model to validate the response body if validate_response is set to True.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>obj_in</code> <code>dict | ProxmoxBaseModel</code> <p>Resource</p> required <code>data_key</code> <code>str</code> <p>Proxmox API typically returns everything in 'data' key, this is used to extract the relevant data directly from the ClientResponse</p> <code>''</code> <code>module_model</code> <code>tuple[str, str]</code> <p>Path to module and model to dynamically load if using Pydantic validation library</p> <code>None</code> <code>validate_response</code> <code>bool</code> <p>Validate the response using Pydantic</p> <code>False</code> <code>response_model</code> <code>tuple[str, str]</code> <p>Path to module and model to dynamically validate the respose using Pydantic library if this model is the same as the original model to create the object, leave this blank and we will automatically use the <code>module_model</code> to validate the response.</p> <code>None</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def create(\n    self,\n    endpoint: str,\n    obj_in: dict | ProxmoxBaseModel,\n    module_model: tuple[str, str] = None,\n    data_key: str = \"\",\n    validate_response: bool = False,\n    response_model: tuple[str, str] = None,\n    **kwargs,\n) -&gt; ProxmoxBaseModel | dict | None:\n    \"\"\"Create a resource on the Proxmox VE API. As of PVE v8.1, most if not all POST endpoints\n    return null, however when data is returned you can pass a Pydantic model to validate the response\n    body if validate_response is set to True.\n\n    Args:\n        endpoint:           API Endpoint\n        obj_in:             Resource\n        data_key:           Proxmox API typically returns everything in 'data' key, this is\n            used to extract the relevant data directly from the ClientResponse\n        module_model:       Path to module and model to dynamically load if using Pydantic validation library\n        validate_response:  Validate the response using Pydantic\n        response_model:     Path to module and model to dynamically validate the respose using Pydantic library\n            if this model is the same as the original model to create the object, leave this blank and we will\n            automatically use the `module_model` to validate the response.\n    \"\"\"\n    data = self._normalize_data(obj_in=obj_in, module_model=module_model)\n    r_data = await self.http_request(\n        endpoint=endpoint,\n        method=\"POST\",\n        data=data,\n        data_key=data_key,\n        **kwargs,\n    )  # data will automatically set application/x-www-form-urlencoded which Proxmox API is expecting\n\n    # If Pydantic is used, we can validate the response returned back to the user,\n    # we can either pass in a separate model using `response_model`, otherwise if this is empty we assume\n    # the same model passed to update the data can be used to validate the response.\n    # Be careful using the same data model to validate the response as it could be a unique field required\n    # when creating the resource, but is never returned in the object back from the API\n    if self.use_pydantic:\n        if validate_response:\n            if not response_model:\n                response_model = module_model  # Use same Model that was used to create, to validate response\n            validation_model = self._get_pydantic_model(*response_model)\n            r_data = self._model_validate(\n                obj_in=r_data, model=validation_model\n            )\n\n    return r_data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI.delete","title":"<code>delete(endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Delete a resource on the Proxmox VE API.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def delete(self, endpoint: str, **kwargs) -&gt; dict | None:\n    \"\"\"Delete a resource on the Proxmox VE API.\n\n    Args:\n        endpoint:   API Endpoint\n    \"\"\"\n    return await self.http_request(\n        endpoint=endpoint, method=\"DELETE\", **kwargs\n    )\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI.http_request","title":"<code>http_request(endpoint, method, data=None, data_key='', **kwargs)</code>  <code>async</code>","text":"<p>aiohttp request shorthand function to handle simple logic.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>method</code> <code>str</code> <p>HTTP Method (GET, POST, PUT, DELETE)</p> required <code>data_key</code> <code>str</code> <p>nested key to export info if present</p> <code>''</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def http_request(\n    self,\n    endpoint: str,\n    method: str,\n    data: dict = None,\n    data_key: str = \"\",\n    **kwargs,\n) -&gt; dict | None:\n    \"\"\"aiohttp request shorthand function to handle simple logic.\n\n    Args:\n        endpoint:   API Endpoint\n        method:     HTTP Method (GET, POST, PUT, DELETE)\n        data_key:   nested key to export info if present\n    \"\"\"\n    ctx = None\n    match method.upper():\n        case \"GET\":\n            ctx = self.session.get\n        case \"POST\":\n            ctx = self.session.post\n        case \"PUT\":\n            ctx = self.session.put\n        case \"DELETE\":\n            ctx = self.session.delete\n        case _:\n            raise KeyError(f\"Method `{method}` is not valid\")\n\n    r = await ctx(\n        url=f\"/{self.api_version}/{self.api_type}\" + endpoint,\n        data=data,\n        **kwargs,\n    )\n    if not r.ok:\n        r.raise_for_status()\n\n    data = await r.json()\n    if data_key:\n        data = data.get(data_key)\n\n    return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI.query","title":"<code>query(endpoint, data_key='data', module_model=None, **kwargs)</code>  <code>async</code>","text":"<p>Basic function to return the JSON directly from any HTTP operation. As of PVE v8.1, most if not all GET endpoints will return the data nested inside the response in a key called <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>GET, POST, PUT or DELETE</p> required <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>data_key</code> <code>str</code> <p>This is used to extract the relevant data directly from the ClientResponse body</p> <code>'data'</code> <code>module_model</code> <code>tuple[str, str]</code> <p>Path to module and model to dynamically load if using Pydantic library</p> <code>None</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def query(\n    self,\n    endpoint: str,\n    data_key: str = \"data\",\n    module_model: tuple[str, str] = None,\n    **kwargs,\n) -&gt; ProxmoxBaseModel | dict | None:\n    \"\"\"Basic function to return the JSON directly from any HTTP operation. As of PVE v8.1, most if not all GET\n    endpoints will return the data nested inside the response in a key called `data`.\n\n    Args:\n        method:         GET, POST, PUT or DELETE\n        endpoint:       API Endpoint\n        data_key:       This is used to extract the relevant data directly from the ClientResponse body\n        module_model:   Path to module and model to dynamically load if using Pydantic library\n    \"\"\"\n    data = await self.http_request(\n        endpoint=endpoint, data_key=data_key, **kwargs\n    )\n\n    # Most PVE endpoints return null if it doesn't exist, so this logic should be handled by each function\n    # if its expecting some returned data.\n    if not data:\n        return None\n\n    if self.use_pydantic:\n        pydantic_model = self._get_pydantic_model(*module_model)\n        data = self._model_validate(obj_in=data, model=pydantic_model)\n\n    return data\n</code></pre>"},{"location":"code/pyproxmoxveapi/#pyproxmox_ve.api.ProxmoxVEAPI.update","title":"<code>update(endpoint, obj_in=None, module_model=None, data_key='', validate_response=False, response_model=None, **kwargs)</code>  <code>async</code>","text":"<p>Update a resource on the Proxmox VE API. As of PVE v8.1, most if not all PUT endpoints return null, however when data is returned you can pass a Pydantic model to validate the response body if validate_response is set to True. It also appears that the PUT response isn't the new updated object but the old object before the update.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>obj_in</code> <code>dict | ProxmoxBaseModel</code> <p>Resource</p> <code>None</code> <code>data_key</code> <code>str</code> <p>Proxmox API typically returns everything in 'data' key, this is used to extract the relevant data directly from the ClientResponse</p> <code>''</code> <code>module_model</code> <code>tuple[str, str]</code> <p>Path to module and model to dynamically load if using Pydantic validation library</p> <code>None</code> <code>validate_response</code> <code>bool</code> <p>Validate the response using Pydantic</p> <code>False</code> <code>response_model</code> <code>tuple[str, str]</code> <p>Path to module and model to dynamically validate the respose using Pydantic library if this model is the same as the original model to update the object, leave this blank and we will automatically use the <code>module_model</code> to validate the response.</p> <code>None</code> Source code in <code>pyproxmox_ve/api.py</code> <pre><code>async def update(\n    self,\n    endpoint: str,\n    obj_in: dict | ProxmoxBaseModel = None,\n    module_model: tuple[str, str] = None,\n    data_key: str = \"\",\n    validate_response: bool = False,\n    response_model: tuple[str, str] = None,\n    **kwargs,\n) -&gt; ProxmoxBaseModel | dict | None:\n    \"\"\"Update a resource on the Proxmox VE API. As of PVE v8.1, most if\n    not all PUT endpoints return null, however when data is returned you can\n    pass a Pydantic model to validate the response body if validate_response\n    is set to True. It also appears that the PUT response isn't the new\n    updated object but the old object before the update.\n\n    Args:\n        endpoint:           API Endpoint\n        obj_in:             Resource\n        data_key:           Proxmox API typically returns everything in\n            'data' key, this is used to extract the relevant data directly\n            from the ClientResponse\n        module_model:       Path to module and model to dynamically load if\n            using Pydantic validation library\n        validate_response:  Validate the response using Pydantic\n        response_model:     Path to module and model to dynamically validate\n            the respose using Pydantic library if this model is the same as\n            the original model to update the object, leave this blank and we\n            will automatically use the `module_model` to validate the\n            response.\n    \"\"\"\n    data = None\n\n    # Exclude unset to prevent default values updating unset values\n    if obj_in:\n        data = self._normalize_data(\n            obj_in=obj_in,\n            module_model=module_model,\n            exclude_unset=True,\n        )\n\n    # data will automatically set application/x-www-form-urlencoded which\n    # Proxmox API is expecting\n    r_data = await self.http_request(\n        endpoint=endpoint,\n        method=\"PUT\",\n        data=data,\n        data_key=data_key,\n        **kwargs,\n    )\n\n    # If Pydantic is used, we can validate the response returned back to the\n    # user, we can either pass in a separate model using `response_model`,\n    # otherwise if this is empty we assume the same model passed to update\n    # the data can be used to validate the response.\n    # Be careful using the same data model to validate the response as it\n    # could be a unique field required when creating the resource, but is\n    # never returned in the object back from the API\n    if self.use_pydantic:\n        if validate_response:\n            if not response_model:\n                response_model = module_model  # Use same Model that was used to update, to validate response\n            validation_model = self._get_pydantic_model(*response_model)\n            r_data = self._model_validate(\n                obj_in=r_data, model=validation_model\n            )\n\n    return r_data\n</code></pre>"},{"location":"code/models/base/","title":"Base","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>pyproxmox_ve/models/base.py</code> <pre><code>class ProxmoxBaseModel(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n        alias_generator=normalize_keys,\n        use_enum_values=True,\n    )\n</code></pre>"},{"location":"code/models/user/","title":"User","text":"<p>             Bases: <code>ProxmoxBaseModel</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserTokenBase(ProxmoxBaseModel):\n    expire: Optional[int] = 0\n    privsep: Optional[int] = 1\n</code></pre> <p>             Bases: <code>UserTokenBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserToken(UserTokenBase):\n    comment: Optional[str] = None\n    tokenid: Optional[str] = None\n</code></pre> <p>             Bases: <code>ProxmoxBaseModel</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserTokenResponse(ProxmoxBaseModel):\n    full_tokenid: str\n    info: dict\n    value: str\n</code></pre> <p>             Bases: <code>ProxmoxBaseModel</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserBase(ProxmoxBaseModel):\n    userid: Optional[str] = None\n    comment: Optional[str] = None\n    email: Optional[str] = None\n    enable: Optional[int] = None\n    expire: Optional[int] = 0\n    firstname: Optional[str] = None\n    groups: Optional[list[str] | str] = None\n    keys: Optional[list[str]] = []\n    lastname: Optional[str] = None\n</code></pre> <p>             Bases: <code>UserBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserCreate(UserBase):\n    userid: str\n    password: Optional[str] = None\n</code></pre> <p>             Bases: <code>UserBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserUpdate(UserBase):\n    append: Optional[int] = None\n</code></pre> <p>             Bases: <code>UserTokenBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserUniqueToken(UserTokenBase):\n    pass\n</code></pre> <p>             Bases: <code>UserBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class User(UserBase):\n    realm_type: Optional[str] = None\n    tfa_locked_until: Optional[int] = None\n    tokens: Optional[list[UserToken]] = []\n    totp_locked: Optional[int] = None\n</code></pre> <p>             Bases: <code>UserBase</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserWithTokenDict(UserBase):\n    tokens: Optional[Dict[str, UserUniqueToken]] = None\n</code></pre> <p>             Bases: <code>ProxmoxBaseModel</code></p> Source code in <code>pyproxmox_ve/models/user.py</code> <pre><code>class UserTFAType(ProxmoxBaseModel):\n    realm: Literal[\"oauth\", \"yubico\"]\n    types: list[Any]\n    user: Literal[\"oauth\", \"yubico\"]\n</code></pre>"},{"location":"contributing/branch_structure/","title":"Branch Structure","text":"<p>Keeping it simple, no one is allowed to push directly into the main branch unless you are an administrator and its a last resort, however its strongly advised never to push directly to main to perform a hotfix due to the workflow of creating a release from the main branch to kick off the PyPI package upload.</p> <p>Info</p> <p>The \"staging\" branch is simply called <code>dev</code>. This branch should incorprate all feature branches and run CI/CD to perform all relevant tests before a merge request is created into <code>main</code>.</p> <p></p> <p>Typically, you should raise an issue (or create an issue from a project task) and assign a branch to the relevant issue, issues are used to track progress and then will be used to merge into the <code>dev</code> branch. Always ensure before you create a merge request into <code>dev</code>, that your feature branch is up to date with the latest dev branch to avoid merge conflicts.</p>"},{"location":"contributing/coding_style/","title":"Coding Style","text":"<ul> <li>Main guidelines are:<ul> <li>Use python type hinting in every function and class, including return types</li> <li>Always use docstrings for Classes and Functions/Methods</li> <li>Always prefer double-quotes rather than single quotes</li> <li>Adhere as close as possible to google style docstrings, auto-generated documentation is dependent on it and a merge request will not make it into <code>dev</code> if they are missing</li> <li>Always indent with 4 spaces, no more, no less</li> <li>Naming of classes should always be CamelCase and functions should be snake_case</li> <li>Never raise exceptions from the base Exception, write custom ones if required</li> </ul> </li> <li>Minimum version of Python to use during development and testing must be <code>3.10.12</code></li> <li>Always use f-strings when possible as they are far more superior than <code>%</code> and <code>.format()</code> in most cases</li> <li>Always write tests for any new functions/API calls implemented or changed (if the logic has changed)</li> <li>All functions should follow the typical API documentation format, more on this can be found here <code>to-do</code></li> <li>List comprehensions should always be used where possible unless the code is too ugly and readable, that is for you and the reviewer to agree with :-)</li> </ul>"},{"location":"contributing/contributing/","title":"Contributing","text":"<p>When contributing to this project, please first discuss the change you wish to make via discussions, an issue or an informal option such as Discord.</p> <p>Please note we have a code of conduct and it's simply 1 rule, don't be a dick.</p> <p>Any feedback for the contributing workflows whether it be the branch structure, coding style, tests or general feedback of the implementation is welcome and should be brought up either as a discussion/issue or informally over a chat like Discord. Do not use emails.</p>"},{"location":"contributing/tests/","title":"Tests","text":"<p>pytest is the testing framework of choice in this project. If you are not very familiar with the basics of pytest, I would recommend reading the documentation or having a look at the tests in this project to see the structure and provided functionality.</p> <p>Each API endpoint or class/function that interacts with a resource which changes potential production data must implement a test and pass before a merge request is accepted.</p>"},{"location":"contributing/tests/#test-structure","title":"Test Structure","text":"<p>All tests belong in the <code>tests</code> directory of the project. The structure of this folder may change from time to time but the basis is that for every API endpoint, you try to group them cleanly into their respective files according to the API endpoint path, prefixed with <code>test_</code>. Here are some examples:</p> <p><code>/access/users*</code> endpoints are resources related to web UI users, we can create users, delete users, update fields, create API tokens, etc... A <code>GET</code> to <code>/access/users</code> will return a list of users, so to access these resources in Python, we would do:</p> <pre><code>from pyproxmox_ve import ProxmoxVEAPI\n\napi = ProxmoxVEAPI()\napi.access.users        # This is the AccessUsersAPI object stored in `pyproxmox_ve/resources/access/users/users.py`\n</code></pre> <p>Methods should be self documenting in a way that I can figure out the purpose of it, so to get all users, I can use: <pre><code>users = api.access.users.get_users()\n</code></pre></p> <p>There is also another endpoint where I can edit a users specific API token using a <code>PUT</code> to the <code>/access/users/{userid}/token/{tokenid}</code> endpoint. Since there are not many resources under the user path, we've opted to fit them all in the single file instead of creating more files, for example instead of doing this:</p> <pre><code>api.access.users.tokens.get_user_token(user_id=\"root@pam\", token_id=\"test_token\")\n\n# I can do this instead\napi.access.users.get_user_token(user_id=\"root@pam\", token_id=\"test_token\")\n</code></pre> <p>Note</p> <p>Remember, every class and method must be documented with a docstring and should always have type annotations/hints to improve the developer experience.</p>"},{"location":"contributing/tests/#test-infrastructure","title":"Test Infrastructure","text":""}]}